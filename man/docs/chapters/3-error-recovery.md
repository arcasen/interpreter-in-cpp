## Panic Mode 错误恢复 （ Panic Mode Error Recovery ）

在编译原理（Compiler Design）中，Panic Mode（恐慌模式）是一种常见的语法错误恢复策略，主要用于语法分析（Parsing）阶段。 Panic Mode 是处理编译时语法错误的最简单且最流行的方法之一，当解析器遇到无法处理的无效输入时，通过“恐慌”方式快速恢复，继续分析剩余代码，从而避免整个编译过程崩溃。基本思想是一旦检测到错误，语法分析器就“恐慌”起来，认为当前所处的状态（比如正在分析一个结构）已经不可靠了。于是丢弃后续的输入符号（Token），直到找到一个同步点（synchronizing token），然后从该点重新开始分析。

现在要分析典型的四则运算表达式文法（递归下降风格）的同步点（synchronizing token）。
通常，同步点会选择在一个非终结符的 FIRST 集或一个规则结束后的 FOLLOW 集中的 Token。  

### 非终结符的 FIRST 集合 和 FOLLOW 集合

四则运算表达式文法的非终结符和终结符：

- 非终结符：`expr`, `term`, `factor`。  
- 终结符：`+`, `-`, `*`, `/`, `(`, `)`, `digit`，以及输入结束 `$`。（ `integer` 可视为终结符 `digit` 或直接处理为数字令牌）

FIRST 集合：

- FIRST(factor) = { `(`, `digit` }
- FIRST(term) = { `(`, `digit` }
- FIRST(expr) = { `(`, `digit` }

FOLLOW 集合：

- FOLLOW(expr)   = { `)`, `$` }
- FOLLOW(term)   = { `+`, `-`, `)`, `$` }
- FOLLOW(factor) = { `*`, `/`, `+`, `-`, `)`, `$` }

### 同步点的选择

在递归下降分析中：

- 进入某个非终结符的函数时，如果当前 Token 不在它的 FIRST 集里，可以报错，并跳过 Token 直到遇到 FOLLOW 中的 Token。  
- FOLLOW 集里的 Token 可作为从该非终结符退出的同步点。  

在 Panic Mode 中，对于每个非终结符，使用其 FOLLOW 集中的终结符作为同步点（丢弃 Token 直到遇到这些）。这能确保恢复到“预期结束”位置，避免过度丢弃有效代码。

| 非终结符   | FOLLOW 集（同步点） | 解释                                         |
| --------- | -------------------- | ---------------------------------------- |
| **expr**   | {`)`, `$`}                     | 表达式结束于右括号或文件末尾。   |
| **term**   | {`+`, `-`, `)`, `$`}           | 项结束于加减运算符、右括号或末尾。 |
| **factor** | {`*`, `/`, `+`, `-`, `)`, `$`} | 因子结束于乘除/加减运算符、右括号或末尾。|

: 同步点的选择 {.striped}

同步点不一定只能选 FOLLOW 集。FOLLOW 集是推荐和最优的选择，但实际实现中可以灵活调整，甚至使用固定或自定义的同步点集。

### 同步点为什么不能（或不宜）用 FIRST 集

在自顶向下解析（如 LL(1) 解析器）的错误恢复机制中，同步点（synchronization points）的主要目的是在遇到错误时“同步”输入流，继续解析而非崩溃。通常采用 panic-mode 错误恢复：当栈顶非终结符 A 无法匹配当前输入时，跳过输入符号直到遇到可能跟随 A 后的终结符（即 FOLLOW(A) 中的符号），然后弹出 A 并继续。

#### 为什么用 FOLLOW 集作为同步点？

- 语义匹配：FOLLOW(A) 精确表示“在 A 后可能出现的终结符”，这符合同步的逻辑——它告诉解析器“在 A 结束后，输入应该是什么样的符号”，从而安全地恢复上下文。
  
- 避免无限循环：使用 FOLLOW 可以确保跳过后，继续从正确的位置解析更高层的结构（如在表达式中，遇到 + 后可以继续 term）。
  
- 标准实践：在经典编译器设计（如 Dragon Book）中，同步点明确定义为 FOLLOW 集。

#### 为什么不能（或不宜）用 FIRST 集？

- 语义不匹配：FIRST(A) 表示从 A 开始可能出现的首终结符，用于选择产生式（预测分析表中的行选择），而非“跟随后”的同步。它描述 A 的开头，不是结束后的预期符号。如果用 FIRST(A) 作为同步点，会导致：

- 错误跳过：例如，栈顶是 expr，但当前输入是 +（不匹配 FIRST(expr)），如果用 FIRST(expr) = { +, −, (, id, ... } 同步，会跳过 +（因为它在 FIRST 中），但 + 其实可能是 FOLLOW(expr) 中的符号，用于连接多个 term，导致解析中断。
  
- 过度匹配：FIRST 集往往较大（包含多种可能起点），容易跳过多余输入，丢失上下文或造成新错误。
不安全：在嵌套结构中（如括号内 expr），用 FIRST 可能误判内部/外部边界，导致栈污染或无限递归。
